<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Scanner;&#10;&#10;public class Main {&#10;    private static ArrayList&lt;Ring&gt; turm = null;&#10;    private static ArrayList&lt;Ring&gt; pfahl1;&#10;    private static ArrayList&lt;Ring&gt; pfahl2;&#10;    private static ArrayList&lt;Ring&gt; pfahl3;&#10;&#10;    private static String rep(String s, int count) {&#10;        return count &gt; 0 ? s.repeat(count) : &quot;&quot;;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.print(&quot;Anzahl Ringe: &quot;);&#10;        int anzahlRinge = sc.nextInt();&#10;        int minimalZuege = (1 &lt;&lt; anzahlRinge) - 1;&#10;&#10;        // prepare initial tower&#10;        turm = new ArrayList&lt;&gt;(anzahlRinge);&#10;        for (int i = anzahlRinge - 1; i &gt;= 0; i--) {&#10;            Ring ring = new Ring(i + 1);&#10;            ring.setPosition(i);&#10;            turm.add(ring);&#10;        }&#10;&#10;        // initialize pegs&#10;        pfahl1 = new ArrayList&lt;&gt;(turm);&#10;        pfahl2 = new ArrayList&lt;&gt;();&#10;        pfahl3 = new ArrayList&lt;&gt;();&#10;&#10;        boolean won = false;&#10;        int anzahlZuege = 0;&#10;        // game loop&#10;        while (!won) {&#10;            anzahlZuege++;&#10;            printTurm();&#10;            System.out.print(&quot;\n&quot; + &quot;\n&quot; + &quot;Zug eingeben (RingLabel ZielPfahl), z.B. A 3: &quot;);&#10;            String label = sc.next();&#10;            int ziel = sc.nextInt();&#10;            ArrayList&lt;Ring&gt; src = null;&#10;            // determine source peg by top ring label&#10;            if (!pfahl1.isEmpty() &amp;&amp; pfahl1.get(pfahl1.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl1;&#10;            else if (!pfahl2.isEmpty() &amp;&amp; pfahl2.get(pfahl2.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl2;&#10;            else if (!pfahl3.isEmpty() &amp;&amp; pfahl3.get(pfahl3.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl3;&#10;            else {&#10;                System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Kein oberer Ring mit Label &quot; + label);&#10;                continue;&#10;            }&#10;            // perform move&#10;            Ring moving = src.remove(src.size() - 1);&#10;            ArrayList&lt;Ring&gt; dest;&#10;            switch (ziel) {&#10;                case 1:&#10;                    dest = pfahl1;&#10;                    break;&#10;                case 2:&#10;                    dest = pfahl2;&#10;                    break;&#10;                case 3:&#10;                    dest = pfahl3;&#10;                    break;&#10;                default:&#10;                    System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Ungültiger Pfahl: &quot; + ziel);&#10;                    src.add(moving);&#10;                    continue;&#10;            }&#10;            // validate move&#10;            if (dest.isEmpty() || dest.get(dest.size() - 1).getGroesse() &gt; moving.getGroesse()) {&#10;                dest.add(moving);&#10;            } else {&#10;                System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Ungültiger Zug: größerer Ring auf kleinerem&quot;);&#10;                src.add(moving);&#10;            }&#10;            // check win&#10;            if (pfahl3.size() == turm.size()) {&#10;                printTurm();&#10;                System.out.println(&quot;\n\nGEWONNEN!&quot;);&#10;                System.out.println(&quot;Anzahl Züge: &quot; + anzahlZuege);&#10;                System.out.println(&quot;Minimale Anzahl Züge: &quot; + minimalZuege);&#10;                // Simulation prompt&#10;                System.out.print(&quot;Simulation der optimalen Lösung anzeigen? (J/N): &quot;);&#10;                String sim = sc.next();&#10;                if (sim.equalsIgnoreCase(&quot;J&quot;)) {&#10;                    // reset pegs&#10;                    pfahl1.clear(); pfahl2.clear(); pfahl3.clear();&#10;                    pfahl1.addAll(turm);&#10;                    printTurm();&#10;                    try {&#10;                        simulateOptimal(anzahlRinge, pfahl1, pfahl2, pfahl3, 1, 2, 3);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;                won = true;&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void printTurm() {&#10;        int maxHeight = turm.size();&#10;        int maxRingWidth = 2 * maxHeight + 1;&#10;&#10;&#10;        for (int level = maxHeight - 1; level &gt;= 0; level--) {&#10;            // peg 1&#10;            if (pfahl1.size() &gt; level) {&#10;                Ring ring = pfahl1.get(level);&#10;                int size = ring.getGroesse();&#10;                String stars = rep(&quot;*&quot;, size) + ring.getLabel() + rep(&quot;*&quot;, size);&#10;                int printWidth = size * 2 + 1;&#10;                int padLeft = Math.max(0, (maxRingWidth - printWidth) / 2);&#10;                int padRight = Math.max(0, maxRingWidth - printWidth - padLeft);&#10;                System.out.print(rep(&quot; &quot;, padLeft) + stars + rep(&quot; &quot;, padRight) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad) + &quot;|&quot; + rep(&quot; &quot;, pad) + &quot;\t\t&quot;);&#10;            }&#10;            // peg 2&#10;            if (pfahl2.size() &gt; level) {&#10;                Ring ring2 = pfahl2.get(level);&#10;                int size2 = ring2.getGroesse();&#10;                String stars2 = rep(&quot;*&quot;, size2) + ring2.getLabel() + rep(&quot;*&quot;, size2);&#10;                int printWidth2 = size2 * 2 + 1;&#10;                int padLeft2 = Math.max(0, (maxRingWidth - printWidth2) / 2);&#10;                int padRight2 = Math.max(0, maxRingWidth - printWidth2 - padLeft2);&#10;                System.out.print(rep(&quot; &quot;, padLeft2) + stars2 + rep(&quot; &quot;, padRight2) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad2 = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad2) + &quot;|&quot; + rep(&quot; &quot;, pad2) + &quot;\t\t&quot;);&#10;            }&#10;            // peg 3&#10;            if (pfahl3.size() &gt; level) {&#10;                Ring ring3 = pfahl3.get(level);&#10;                int size3 = ring3.getGroesse();&#10;                String stars3 = rep(&quot;*&quot;, size3) + ring3.getLabel() + rep(&quot;*&quot;, size3);&#10;                int printWidth3 = size3 * 2 + 1;&#10;                int padLeft3 = Math.max(0, (maxRingWidth - printWidth3) / 2);&#10;                int padRight3 = Math.max(0, maxRingWidth - printWidth3 - padLeft3);&#10;                System.out.print(rep(&quot; &quot;, padLeft3) + stars3 + rep(&quot; &quot;, padRight3) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad3 = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad3) + &quot;|&quot; + rep(&quot; &quot;, pad3) + &quot;\t\t&quot;);&#10;            }&#10;            System.out.println();&#10;        }&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            String label = &quot;Pfahl &quot; + (i + 1);&#10;            int padLeft = Math.max(0, (maxRingWidth - label.length()) / 2);&#10;            int padRight = Math.max(0, maxRingWidth - label.length() - padLeft);&#10;            System.out.print(rep(&quot; &quot;, padLeft) + label + rep(&quot; &quot;, padRight) + &quot;\t\t&quot;);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    // recursive simulation of optimal moves&#10;    private static void simulateOptimal(int n, ArrayList&lt;Ring&gt; src, ArrayList&lt;Ring&gt; aux, ArrayList&lt;Ring&gt; dest, int srcNum, int auxNum, int destNum) throws InterruptedException {&#10;        if (n == 0) return;&#10;        simulateOptimal(n - 1, src, dest, aux, srcNum, destNum, auxNum);&#10;        Ring ring = src.remove(src.size() - 1);&#10;        dest.add(ring);&#10;        System.out.println(&quot;\n\nBewege Ring &quot; + ring.getLabel() + &quot; von Pfahl &quot; + srcNum + &quot; zu Pfahl &quot; + destNum);&#10;        printTurm();&#10;        Thread.sleep(1000);&#10;        simulateOptimal(n - 1, aux, src, dest, auxNum, srcNum, destNum);&#10;    }&#10;}" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Scanner;&#10;&#10;public class Main {&#10;    private static ArrayList&lt;Ring&gt; turm = null;&#10;    private static ArrayList&lt;Ring&gt; pfahl1;&#10;    private static ArrayList&lt;Ring&gt; pfahl2;&#10;    private static ArrayList&lt;Ring&gt; pfahl3;&#10;&#10;    private static String rep(String s, int count) {&#10;        return count &gt; 0 ? s.repeat(count) : &quot;&quot;;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;&#10;        Scanner sc = new Scanner(System.in);&#10;        System.out.print(&quot;Anzahl Ringe: &quot;);&#10;        int anzahlRinge = sc.nextInt();&#10;        int minimalZuege = (1 &lt;&lt; anzahlRinge) - 1;&#10;&#10;        // prepare initial tower&#10;        turm = new ArrayList&lt;&gt;(anzahlRinge);&#10;        for (int i = anzahlRinge - 1; i &gt;= 0; i--) {&#10;            Ring ring = new Ring(i + 1);&#10;            ring.setPosition(i);&#10;            turm.add(ring);&#10;        }&#10;&#10;        // initialize pegs&#10;        pfahl1 = new ArrayList&lt;&gt;(turm);&#10;        pfahl2 = new ArrayList&lt;&gt;();&#10;        pfahl3 = new ArrayList&lt;&gt;();&#10;&#10;        boolean won = false;&#10;        int anzahlZuege = 0;&#10;        // game loop&#10;        while (!won) {&#10;            anzahlZuege++;&#10;            printTurm();&#10;            System.out.print(&quot;\n&quot; + &quot;\n&quot; + &quot;Zug eingeben (RingLabel ZielPfahl), z.B. A 3: &quot;);&#10;            String label = sc.next();&#10;            int ziel = sc.nextInt();&#10;            ArrayList&lt;Ring&gt; src = null;&#10;            // determine source peg by top ring label&#10;            if (!pfahl1.isEmpty() &amp;&amp; pfahl1.get(pfahl1.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl1;&#10;            else if (!pfahl2.isEmpty() &amp;&amp; pfahl2.get(pfahl2.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl2;&#10;            else if (!pfahl3.isEmpty() &amp;&amp; pfahl3.get(pfahl3.size() - 1).getLabel().equalsIgnoreCase(label)) src = pfahl3;&#10;            else {&#10;                System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Kein oberer Ring mit Label &quot; + label);&#10;                continue;&#10;            }&#10;            // perform move&#10;            Ring moving = src.remove(src.size() - 1);&#10;            ArrayList&lt;Ring&gt; dest;&#10;            switch (ziel) {&#10;                case 1: // Ungueltiger Pfahl replace lower below&#10;                    dest = pfahl1;&#10;                    break;&#10;                case 2:&#10;                    dest = pfahl2;&#10;                    break;&#10;                case 3:&#10;                    dest = pfahl3;&#10;                    break;&#10;                default:&#10;                    System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Ungueltiger Pfahl: &quot; + ziel);&#10;                    src.add(moving);&#10;                    continue;&#10;            }&#10;            // validate move&#10;            if (dest.isEmpty() || dest.get(dest.size() - 1).getGroesse() &gt; moving.getGroesse()) {&#10;                dest.add(moving);&#10;            } else {&#10;                System.out.println(&quot;\n&quot; + &quot;\n&quot; + &quot;Ungueltiger Zug: groesserer Ring auf kleinerem&quot;);&#10;                src.add(moving);&#10;            }&#10;            // check win&#10;            if (pfahl3.size() == turm.size()) {&#10;                printTurm();&#10;                System.out.println(&quot;\n\nGEWONNEN!&quot;);&#10;                System.out.println(&quot;Anzahl Züge: &quot; + anzahlZuege);&#10;                System.out.println(&quot;Minimale Anzahl Zuege: &quot; + minimalZuege);&#10;                // Simulation prompt&#10;                System.out.print(&quot;Simulation der optimalen Loesung anzeigen? (J/N): &quot;);&#10;                String sim = sc.next();&#10;                if (sim.equalsIgnoreCase(&quot;J&quot;)) {&#10;                    // reset pegs&#10;                    pfahl1.clear(); pfahl2.clear(); pfahl3.clear();&#10;                    pfahl1.addAll(turm);&#10;                    printTurm();&#10;                    try {&#10;                        simulateOptimal(anzahlRinge, pfahl1, pfahl2, pfahl3, 1, 2, 3);&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                    }&#10;                }&#10;                won = true;&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void printTurm() {&#10;        int maxHeight = turm.size();&#10;        int maxRingWidth = 2 * maxHeight + 1;&#10;&#10;&#10;        for (int level = maxHeight - 1; level &gt;= 0; level--) {&#10;            // peg 1&#10;            if (pfahl1.size() &gt; level) {&#10;                Ring ring = pfahl1.get(level);&#10;                int size = ring.getGroesse();&#10;                String stars = rep(&quot;*&quot;, size) + ring.getLabel() + rep(&quot;*&quot;, size);&#10;                int printWidth = size * 2 + 1;&#10;                int padLeft = Math.max(0, (maxRingWidth - printWidth) / 2);&#10;                int padRight = Math.max(0, maxRingWidth - printWidth - padLeft);&#10;                System.out.print(rep(&quot; &quot;, padLeft) + stars + rep(&quot; &quot;, padRight) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad) + &quot;|&quot; + rep(&quot; &quot;, pad) + &quot;\t\t&quot;);&#10;            }&#10;            // peg 2&#10;            if (pfahl2.size() &gt; level) {&#10;                Ring ring2 = pfahl2.get(level);&#10;                int size2 = ring2.getGroesse();&#10;                String stars2 = rep(&quot;*&quot;, size2) + ring2.getLabel() + rep(&quot;*&quot;, size2);&#10;                int printWidth2 = size2 * 2 + 1;&#10;                int padLeft2 = Math.max(0, (maxRingWidth - printWidth2) / 2);&#10;                int padRight2 = Math.max(0, maxRingWidth - printWidth2 - padLeft2);&#10;                System.out.print(rep(&quot; &quot;, padLeft2) + stars2 + rep(&quot; &quot;, padRight2) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad2 = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad2) + &quot;|&quot; + rep(&quot; &quot;, pad2) + &quot;\t\t&quot;);&#10;            }&#10;            // peg 3&#10;            if (pfahl3.size() &gt; level) {&#10;                Ring ring3 = pfahl3.get(level);&#10;                int size3 = ring3.getGroesse();&#10;                String stars3 = rep(&quot;*&quot;, size3) + ring3.getLabel() + rep(&quot;*&quot;, size3);&#10;                int printWidth3 = size3 * 2 + 1;&#10;                int padLeft3 = Math.max(0, (maxRingWidth - printWidth3) / 2);&#10;                int padRight3 = Math.max(0, maxRingWidth - printWidth3 - padLeft3);&#10;                System.out.print(rep(&quot; &quot;, padLeft3) + stars3 + rep(&quot; &quot;, padRight3) + &quot;\t\t&quot;);&#10;            } else {&#10;                int pad3 = Math.max(0, (maxRingWidth - 1) / 2);&#10;                System.out.print(rep(&quot; &quot;, pad3) + &quot;|&quot; + rep(&quot; &quot;, pad3) + &quot;\t\t&quot;);&#10;            }&#10;            System.out.println();&#10;        }&#10;&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            String label = &quot;Pfahl &quot; + (i + 1);&#10;            int padLeft = Math.max(0, (maxRingWidth - label.length()) / 2);&#10;            int padRight = Math.max(0, maxRingWidth - label.length() - padLeft);&#10;            System.out.print(rep(&quot; &quot;, padLeft) + label + rep(&quot; &quot;, padRight) + &quot;\t\t&quot;);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    // recursive simulation of optimal moves&#10;    private static void simulateOptimal(int n, ArrayList&lt;Ring&gt; src, ArrayList&lt;Ring&gt; aux, ArrayList&lt;Ring&gt; dest, int srcNum, int auxNum, int destNum) throws InterruptedException {&#10;        if (n == 0) return;&#10;        simulateOptimal(n - 1, src, dest, aux, srcNum, destNum, auxNum);&#10;        Ring ring = src.remove(src.size() - 1);&#10;        dest.add(ring);&#10;        System.out.println(&quot;\n\nBewege Ring &quot; + ring.getLabel() + &quot; von Pfahl &quot; + srcNum + &quot; zu Pfahl &quot; + destNum);&#10;        printTurm();&#10;        Thread.sleep(1000);&#10;        simulateOptimal(n - 1, aux, src, dest, auxNum, srcNum, destNum);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Turmteil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Turmteil.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;public class Turmteil {&#10;    private int groesse;&#10;    private int position = 0;&#10;&#10;    public Turmteil(int groesse) {&#10;        this.groesse = groesse;&#10;    }&#10;&#10;    public int getGroesse() {&#10;        return groesse;&#10;    }&#10;&#10;    public int getPosition() {&#10;        return position;&#10;    }&#10;&#10;    public void setPosition(int position) {&#10;        this.position = position;&#10;    }&#10;&#10;    public void setGroesse(int groesse) {&#10;        this.groesse = groesse;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Turmteil {&#10;    private int groesse;&#10;    private int position = 0;&#10;&#10;    public Turmteil(int groesse) {&#10;        this.groesse = groesse;&#10;    }&#10;&#10;    public int getGroesse() {&#10;        return groesse;&#10;    }&#10;&#10;    public int getPosition() {&#10;        return position;&#10;    }&#10;&#10;    public void setPosition(int position) {&#10;        this.position = position;&#10;    }&#10;&#10;    public void setGroesse(int groesse) {&#10;        this.groesse = groesse;&#10;    }&#10;&#10;    public String getLabel() {&#10;        return String.valueOf((char)('A' + groesse - 1));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>